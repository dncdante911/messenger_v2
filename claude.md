# Контекст проекта: WorldMates Messenger (WM Messenger / WM-Talk)

## 1. Обзор проекта
**Название:** WorldMates Messenger (WM Messenger)
**Экосистема:** Интегрируется с основной социальной сетью `worldmates.club` и связанными сервисами.
**Маскот и брендинг:** Пес Волли (Wally). Тон UI/UX должен быть дружелюбным, современным и вовлекающим.
**Главная цель:** Разработка и поддержка быстрого, безопасного и масштабируемого современного мессенджера для Android с надежной серверной инфраструктурой.

## 2. Технологический стек и инфраструктура
Проект опирается на гибридную архитектуру, объединяющую кастомизированное базовое ядро с современными движками и нативными клиентами.

* **Движок реального времени / Серверное ядро:** `Node.js`. Обрабатывает WebSockets, обмен сообщениями, статусы присутствия и быстрые операции ввода-вывода.
* **REST API / Социальное ядро:** `PHP`. Базируется на лицензионном скрипте **WoWonder Ultimate social network**. Обрабатывает аутентификацию, профили и социальный граф.
* **Мобильный клиент:** `Android (Kotlin)`. Нативная разработка.
* **CDN и хранилище медиа:** Управление контентом (личные стикер-паки, GIF, анимации и прочие медиафайлы) реализовано на базе **Strapi** и раздается через `cdn.worldmates.club`.
* **Аудио/Видео и прямые трансляции:** Все WebRTC-соединения, звонки и стримы маршрутизируются через собственный выделенный сервер **Coturn**.
* **Сеть и хостинг:** Работает на собственном оборудовании (дата-центр `sthost.pro`), используется Proxmox, HAProxy и iptables/nftables для фильтрации и маршрутизации.

## 3. Безопасность и шифрование (Критически важно)
* **Гибридная система шифрования сообщений:** * В мобильном приложении (Android) используется связка **AES-256-GCM + E2EE** (End-to-End Encryption) для максимальной приватности.
  * Для сохранения возможности читать переписку на основном сайте, веб-версия по умолчанию использует шифрование **AES-128**.
  * Архитектура ключей и передачи сообщений должна учитывать этот гибридный механизм.
* **Защита от взлома и инъекций:** Любой генерируемый код (как Node.js, так и PHP) должен строго фильтровать пользовательский ввод. Обязательна защита от SQLi, XSS, CSRF, а также предотвращение несанкционированного доступа к API.

## 4. Твоя роль (Claude)
Действуй как эксперт Full-Stack разработчик, специалист по кибербезопасности и старший системный администратор. 
* При написании на **Node.js**, фокусируйся на асинхронной производительности и безопасной маршрутизации зашифрованных пакетов.
* При работе с **PHP / WoWonder API**, пиши чистый код, не допускающий никаких инъекций, и уважай существующую схему БД.
* При написании на **Kotlin**, реализуй надежную работу с E2EE и AES-256-GCM, придерживаясь современных стандартов (Coroutines, Flow).

## 5. Стандарты кодирования и алгоритм работы
1. **Модульность:** Разделение ответственности критически важно, особенно при работе со смешанным шифрованием (App vs Web).
2. **Обработка ошибок:** «Тихие» сбои недопустимы. Логируй ошибки, не раскрывая при этом чувствительные данные пользователей.
3. **Согласование изменений:** Прежде чем предлагать серьезные архитектурные изменения (особенно в логике шифрования или структуре БД), запрашивай подтверждение.
4. **Готовый код:** Предоставляй полные, готовые к внедрению фрагменты кода с четкими инструкциями по их размещению на сервере или в приложении.

## 6. Пример логики гибридного шифрования (Hybrid Encryption Flow)
Для реализации требования «AES-256-GCM E2EE в приложении + AES-128 на сайте», используем архитектуру Dual Payload (двойной пакет) при отправке сообщений.

**Базовые принципы (App - Kotlin):**
1. У каждого мобильного клиента есть пара ключей (Public/Private), генерируемая при входе. Private Key никогда не покидает устройство (хранится в Android Keystore).
2. Public Key отправляется на сервер и привязывается к профилю WoWonder.

**Базовые принципы (Web/API - PHP/Node.js):**
1. Для каждого пользователя генерируется `Web_Sync_Key` (симметричный AES-128 ключ), который хранится в БД WoWonder (в зашифрованном виде, доступен только после авторизации пользователя на сайте).

**Алгоритм отправки сообщения (Alice -> Bob):**
1. **Генерация:** Приложение Alice генерирует одноразовый симметричный ключ сессии для конкретного сообщения.
2. **E2EE Payload (для приложения Bob'а):** Сообщение шифруется алгоритмом **AES-256-GCM**. Ключ сессии шифруется публичным ключом Bob'а. Это гарантирует, что только мобилка Bob'а сможет прочитать эту часть.
3. **Web Payload (для чтения на сайте):** То же самое сообщение шифруется алгоритмом **AES-128** с использованием `Web_Sync_Key` (чтобы веб-версия WoWonder могла расшифровать его "на лету" при открытии браузера).
4. **Маршрутизация (Node.js):** Node.js получает оба пакета. E2EE-пакет пушится через WebSocket Bob'у на телефон.
5. **Хранение (PHP):** Node.js передает Web Payload (AES-128) в PHP API, который безопасно записывает его в базу данных MySQL.

**Твоя задача при написании кода (Claude):**
* В **Node.js**: Реализовать валидацию обоих payload-ов (E2EE и Web) без попыток расшифровать E2EE-часть.
* В **PHP**: Реализовать безопасное сохранение AES-128 пакетов и механизм их расшифровки при загрузке страницы чата на `worldmates.club`. Обязательно использовать `openssl_encrypt/openssl_decrypt` с безопасным вектором инициализации (IV).
* В **Kotlin**: Написать менеджер ключей, который формирует этот "двойной конверт" перед отправкой по WebSocket.

7. Стратегия распределения задач (Node.js Dominance)
Забудь про "холодный" и "горячий" контур в классическом понимании. Теперь правило одно:

Все в Node.js: Сообщения, сокеты, статусы, звонки (WebRTC), авторизация, регистрация, работа с профилями (если API тормозит).

В API (PHP): Только то, что вызывается раз в год и не влияет на пользовательский опыт.

**Строгие правила распределения логики:**
* **Node.js (Горячий контур / High-Speed):** Все моментальные и критичные к скорости отклика операции должны обрабатываться исключительно здесь. Это включает: WebSockets, отправку/получение сообщений (E2EE), статусы «печатает», онлайн/офлайн присутствие, WebRTC-сигналинг для Coturn и любые быстрые микро-запросы.
* **PHP API / WoWonder (Холодный контур / REST):** Все тяжелые, некритичные ко времени выполнения операции остаются на классических API-эндпоинтах. Это включает: первоначальную загрузку тяжелой истории чатов, регистрацию, обновление данных профиля, сложную выборку графа друзей из БД MySQL, загрузку аватаров и фоновые синхронизации.

**Твоя задача при проектировании (Claude):** При разработке нового функционала самостоятельно анализируй требования к скорости. 
1. Если фича требует моментального отклика или постоянного соединения — проектируй архитектуру и пиши код для **Node.js**. 
2. Если это статичный CRUD-запрос или работа с профилем — используй или расширяй существующие эндпоинты **PHP**.

## 8. Инфраструктура, Сеть и Роутинг (Справочник для конфигурации)
Проект работает в сложной сетевой среде с балансировщиком HAProxy и жестким фаерволом nftables. При написании конфигурационных файлов (например, `.env`) или настройке подключений, строго используй следующие параметры:

**1. Node.js (Messenger Server):**
* **Хост:** Внутренний IP `192.168.0.250` (сервер ISPmanager).
* **Порт:** `449`. 
* **Особенность:** HAProxy прокидывает трафик на порт 449 в режиме `mode tcp` напрямую (и установлен `timeout tunnel 1h`). Учитывай это при настройке WebSocket (Socket.io / ws).

**2. Redis (Кэширование и Pub/Sub для Node.js):**
* **Хост:** `192.168.0.250` (или `127.0.0.1`, если Node.js крутится на этой же машине).
* **Порт:** `6379`.
* **Пароль:** `3344Frz@q0607Dm$157`
* **Особенность:** Доступ к Redis закрыт извне через HAProxy ACL (разрешена только подсеть `192.168.0.0/24` и локалхост).

**3. Coturn (WebRTC / Аудио-Видео звонки):**
* **Хост:** `192.168.0.250`.
* **Порты:** `3478`, `5349` (STUN/TURN), а также диапазон `10000-65535` UDP для медиа-трафика.
* **Особенность:** Трафик Coturn идет в обход HAProxy, напрямую пробрасываясь через DNAT (nftables). При генерации конфигурации Coturn или настроек ICE-серверов в клиенте (Kotlin/Web), используй внешние IP сервера (`195.22.131.11` / `46.232.232.38`), но биндь сам сервис на `192.168.0.250`.

**4. Strapi (CDN для стикеров, GIF, файлов):**
* **Хост:** Внутренняя виртуалка `192.168.0.21`, порт `1337`.
* **Внешний доступ:** Доступен по адресу `https://cdn.worldmates.club`.
* **Особенность:** HAProxy сам терминирует SSL-сертификат и передает запросы на Strapi по обычному HTTP. При написании API-запросов к Strapi из Node.js или мобильного приложения всегда обращайся к `cdn.worldmates.club` по HTTPS.

**5. База данных MySQL (WoWonder):**
* **Хост:** Скорее всего `127.0.0.1` или `localhost` в контексте `192.168.0.250`, так как там стоит ISPmanager.
* **Особенность:** Node.js должен иметь прямое подключение к этой БД для верификации токенов и записи/чтения данных, которые не кэшированы в Redis.

**6. Внешние ИП каналы:**
* **Внешние каналы:** На всякий случай вот внешние ип 195.22.131.11 и 46.232.232.38

**Твоя задача (Claude):** Не выдумывай IP-адреса и порты. При генерации кода, особенно блоков подключения к БД, Redis, WebSocket-серверам или WebRTC, используй исключительно данные из этого списка.
